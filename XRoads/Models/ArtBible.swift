//
//  ArtBible.swift
//  XRoads
//
//  Created by Nexus on 2026-02-04.
//  US-V4-024: Art Direction bible model for design token preview
//

import Foundation

// MARK: - ArtBible

/// Represents an Art Direction bible generated by the art-director skill.
struct ArtBible: Codable, Hashable, Sendable {
    let project: String
    let version: String
    var generatedAt: Date?
    var verbalMoodboard: [ArtBibleMoodboard]?
    var designTokens: ArtBibleDesignTokens?
    var colorSystem: [String: ArtBibleColorSwatch]?
    var typographySystem: [String: ArtBibleTypographySpec]?
    var uiComponents: [ArtBibleComponent]?
    var components: [ArtBibleComponent]?
    var photographyDirection: ArtBiblePhotographyDirection?
    var graphicElements: ArtBibleGraphicElements?
    var pageArchitecture: [ArtBiblePage]?
    var referenceURLs: [String]?
    var imageReferences: [String]?

    init(
        project: String,
        version: String = "1.0.0",
        generatedAt: Date? = nil,
        verbalMoodboard: [ArtBibleMoodboard]? = nil,
        designTokens: ArtBibleDesignTokens? = nil,
        colorSystem: [String: ArtBibleColorSwatch]? = nil,
        typographySystem: [String: ArtBibleTypographySpec]? = nil,
        uiComponents: [ArtBibleComponent]? = nil,
        components: [ArtBibleComponent]? = nil,
        photographyDirection: ArtBiblePhotographyDirection? = nil,
        graphicElements: ArtBibleGraphicElements? = nil,
        pageArchitecture: [ArtBiblePage]? = nil,
        referenceURLs: [String]? = nil,
        imageReferences: [String]? = nil
    ) {
        self.project = project
        self.version = version
        self.generatedAt = generatedAt
        self.verbalMoodboard = verbalMoodboard
        self.designTokens = designTokens
        self.colorSystem = colorSystem
        self.typographySystem = typographySystem
        self.uiComponents = uiComponents
        self.components = components
        self.photographyDirection = photographyDirection
        self.graphicElements = graphicElements
        self.pageArchitecture = pageArchitecture
        self.referenceURLs = referenceURLs
        self.imageReferences = imageReferences
    }

    // MARK: - Derived

    var allComponents: [ArtBibleComponent] {
        let merged = (components ?? []) + (uiComponents ?? [])
        var byName: [String: ArtBibleComponent] = [:]
        for component in merged {
            byName[component.name] = component
        }
        return byName.values.sorted { $0.name < $1.name }
    }

    // MARK: - Codable

    private enum CodingKeys: String, CodingKey {
        case project
        case version
        case generatedAt = "generated_at"
        case verbalMoodboard = "verbal_moodboard"
        case designTokens = "design_tokens"
        case colorSystem = "color_system"
        case typographySystem = "typography_system"
        case uiComponents = "ui_components"
        case components
        case photographyDirection = "photography_direction"
        case graphicElements = "graphic_elements"
        case pageArchitecture = "page_architecture"
        case referenceURLs = "reference_urls"
        case references
        case imageReferences = "image_references"
        case inputImages = "input_images"
    }

    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        project = try container.decodeIfPresent(String.self, forKey: .project) ?? "Untitled"
        version = try container.decodeIfPresent(String.self, forKey: .version) ?? "1.0.0"
        generatedAt = try container.decodeIfPresent(Date.self, forKey: .generatedAt)
        verbalMoodboard = try container.decodeIfPresent([ArtBibleMoodboard].self, forKey: .verbalMoodboard)
        designTokens = try container.decodeIfPresent(ArtBibleDesignTokens.self, forKey: .designTokens)
        colorSystem = try container.decodeIfPresent([String: ArtBibleColorSwatch].self, forKey: .colorSystem)
        typographySystem = try container.decodeIfPresent([String: ArtBibleTypographySpec].self, forKey: .typographySystem)
        uiComponents = try container.decodeIfPresent([ArtBibleComponent].self, forKey: .uiComponents)
        components = try container.decodeIfPresent([ArtBibleComponent].self, forKey: .components)
        photographyDirection = try container.decodeIfPresent(ArtBiblePhotographyDirection.self, forKey: .photographyDirection)
        graphicElements = try container.decodeIfPresent(ArtBibleGraphicElements.self, forKey: .graphicElements)
        pageArchitecture = try container.decodeIfPresent([ArtBiblePage].self, forKey: .pageArchitecture)

        referenceURLs = try container.decodeIfPresent([String].self, forKey: .referenceURLs)
        if referenceURLs == nil {
            referenceURLs = try container.decodeIfPresent([String].self, forKey: .references)
        }

        imageReferences = try container.decodeIfPresent([String].self, forKey: .imageReferences)
        if imageReferences == nil {
            imageReferences = try container.decodeIfPresent([String].self, forKey: .inputImages)
        }
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(project, forKey: .project)
        try container.encode(version, forKey: .version)
        try container.encodeIfPresent(generatedAt, forKey: .generatedAt)
        try container.encodeIfPresent(verbalMoodboard, forKey: .verbalMoodboard)
        try container.encodeIfPresent(designTokens, forKey: .designTokens)
        try container.encodeIfPresent(colorSystem, forKey: .colorSystem)
        try container.encodeIfPresent(typographySystem, forKey: .typographySystem)
        try container.encodeIfPresent(uiComponents, forKey: .uiComponents)
        try container.encodeIfPresent(components, forKey: .components)
        try container.encodeIfPresent(photographyDirection, forKey: .photographyDirection)
        try container.encodeIfPresent(graphicElements, forKey: .graphicElements)
        try container.encodeIfPresent(pageArchitecture, forKey: .pageArchitecture)
        try container.encodeIfPresent(referenceURLs, forKey: .referenceURLs)
        try container.encodeIfPresent(imageReferences, forKey: .imageReferences)
    }
}

// MARK: - Design Tokens

struct ArtBibleDesignTokens: Codable, Hashable, Sendable {
    var colors: [String: [String: String]]?
    var typography: ArtBibleTypographyTokens?
    var spacing: [String: Double]?
    var radius: [String: Double]?
}

struct ArtBibleTypographyTokens: Codable, Hashable, Sendable {
    var fontFamily: [String: String]?
    var sizes: [String: Double]?

    private enum CodingKeys: String, CodingKey {
        case fontFamily
        case sizes
    }
}

// MARK: - Color System

struct ArtBibleColorSwatch: Codable, Hashable, Sendable {
    var hex: String
    var name: String?
    var usage: String?
}

// MARK: - Typography System

struct ArtBibleTypographySpec: Codable, Hashable, Sendable {
    var font: String?
    var weight: Double?
    var size: Double?
    var sizeDesktop: Double?
    var sizeMobile: Double?
    var letterSpacing: Double?
    var lineHeight: Double?
    var caseStyle: String?

    private enum CodingKeys: String, CodingKey {
        case font
        case weight
        case size
        case sizeDesktop = "size_desktop"
        case sizeMobile = "size_mobile"
        case letterSpacing = "letter_spacing"
        case lineHeight = "line_height"
        case caseStyle = "case"
    }
}

// MARK: - Components

struct ArtBibleComponent: Codable, Hashable, Sendable {
    var name: String
    var description: String?
    var tokens: [String]?
    var styleSpecs: [String: ArtBiblePrimitive]?
    var visualPrompt: String?
    var interaction: [String: String]?

    private enum CodingKeys: String, CodingKey {
        case name
        case description
        case tokens
        case styleSpecs = "style_specs"
        case visualPrompt = "visual_prompt"
        case interaction
    }
}

// MARK: - Moodboard

struct ArtBibleMoodboard: Codable, Hashable, Sendable {
    var description: String
    var keywords: [String]?
    var aiPrompt: String?

    private enum CodingKeys: String, CodingKey {
        case description
        case keywords
        case aiPrompt = "ai_prompt"
    }
}

// MARK: - Photography Direction

struct ArtBiblePhotographyDirection: Codable, Hashable, Sendable {
    var style: String?
    var lighting: String?
    var composition: String?
    var aiPrompts: [String]?
    var dos: [String]?
    var donts: [String]?

    private enum CodingKeys: String, CodingKey {
        case style
        case lighting
        case composition
        case aiPrompts = "ai_prompts"
        case dos
        case donts
    }
}

// MARK: - Graphic Elements

struct ArtBibleGraphicElements: Codable, Hashable, Sendable {
    var iconStyle: String?
    var decorative: [String]?
    var microInteractions: [String]?

    private enum CodingKeys: String, CodingKey {
        case iconStyle = "icon_style"
        case decorative
        case microInteractions = "micro_interactions"
    }
}

// MARK: - Page Architecture

struct ArtBiblePage: Codable, Hashable, Sendable {
    var page: String
    var sections: [ArtBiblePageSection]?
}

struct ArtBiblePageSection: Codable, Hashable, Sendable {
    var name: String
    var purpose: String?
    var layout: String?
    var visualPrompt: String?
    var copyDirection: ArtBibleCopyDirection?

    private enum CodingKeys: String, CodingKey {
        case name
        case purpose
        case layout
        case visualPrompt = "visual_prompt"
        case copyDirection = "copy_direction"
    }
}

struct ArtBibleCopyDirection: Codable, Hashable, Sendable {
    var tone: String?
    var length: String?
    var keyMessage: String?

    private enum CodingKeys: String, CodingKey {
        case tone
        case length
        case keyMessage = "key_message"
    }
}

// MARK: - Primitive Values

enum ArtBiblePrimitive: Codable, Hashable, Sendable {
    case string(String)
    case number(Double)
    case bool(Bool)

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let value = try? container.decode(Double.self) {
            self = .number(value)
        } else if let value = try? container.decode(Bool.self) {
            self = .bool(value)
        } else {
            let value = try container.decode(String.self)
            self = .string(value)
        }
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .string(let value):
            try container.encode(value)
        case .number(let value):
            try container.encode(value)
        case .bool(let value):
            try container.encode(value)
        }
    }

    var displayValue: String {
        switch self {
        case .string(let value):
            return value
        case .number(let value):
            return String(format: "%.2f", value)
        case .bool(let value):
            return value ? "true" : "false"
        }
    }
}
