import Foundation

// MARK: - Component Context

struct ComponentContext: Hashable, Sendable {
    struct Component: Hashable, Sendable {
        let name: String
        let description: String?
        let usageExample: String
        let tokens: [String]
        let source: ComponentSource
        let filePath: String?
    }

    enum ComponentSource: String, Hashable, Sendable {
        case codebase
        case artBible
        case theme
    }

    let components: [Component]
    let missingComponents: [Component]
    let sourceFiles: [URL]
}

// MARK: - Errors

enum ComponentContextBuilderError: LocalizedError {
    case agentsFileNotFound(String)
    case agentsFileReadFailed(String)
    case agentsFileWriteFailed(String)
    case artBibleDecodeFailed(String)

    var errorDescription: String? {
        switch self {
        case .agentsFileNotFound(let path):
            return "AGENTS.md not found at \(path)."
        case .agentsFileReadFailed(let path):
            return "Failed to read AGENTS.md at \(path)."
        case .agentsFileWriteFailed(let path):
            return "Failed to write AGENTS.md at \(path)."
        case .artBibleDecodeFailed(let path):
            return "Failed to decode art-bible.json at \(path)."
        }
    }
}

// MARK: - Builder

struct ComponentContextBuilder {
    private let fileManager: FileManager
    private let dateFormatter: ISO8601DateFormatter

    init(fileManager: FileManager = .default) {
        self.fileManager = fileManager
        self.dateFormatter = ISO8601DateFormatter()
        self.dateFormatter.formatOptions = [.withInternetDateTime, .withFractionalSeconds]
    }

    func buildContext(projectURL: URL) throws -> ComponentContext {
        var sourceFiles: [URL] = []
        var available: [String: ComponentContext.Component] = [:]

        let codeComponents = scanCodeComponents(in: projectURL)
        for component in codeComponents {
            available[normalizedName(component.name)] = component
        }

        if let themeComponent = themeComponent(in: projectURL) {
            available[normalizedName(themeComponent.name)] = themeComponent
        }

        var missing: [ComponentContext.Component] = []

        if let artBibleURL = findArtBible(in: projectURL) {
            sourceFiles.append(artBibleURL)
            let artBible = try loadArtBible(from: artBibleURL)
            let artComponents = components(from: artBible)

            for component in artComponents {
                let key = normalizedName(component.name)
                let usage = usageExample(for: component.name, tokens: component.tokens ?? [])
                let entry = ComponentContext.Component(
                    name: component.name,
                    description: component.description,
                    usageExample: usage,
                    tokens: component.tokens ?? [],
                    source: .artBible,
                    filePath: nil
                )

                if let existing = available[key] {
                    available[key] = merge(existing: existing, artBible: entry)
                } else {
                    missing.append(entry)
                }
            }
        }

        let components = available.values.sorted { $0.name.localizedCaseInsensitiveCompare($1.name) == .orderedAscending }
        let missingComponents = missing.sorted { $0.name.localizedCaseInsensitiveCompare($1.name) == .orderedAscending }

        return ComponentContext(
            components: components,
            missingComponents: missingComponents,
            sourceFiles: sourceFiles
        )
    }

    func renderSection(for context: ComponentContext) -> String {
        var lines: [String] = []
        lines.append("## Available Components")
        lines.append("<!-- Auto-generated by ComponentContextBuilder on \(dateFormatter.string(from: Date())) -->")

        if context.components.isEmpty {
            lines.append("")
            lines.append("_No components detected yet. Run the Art Direction pipeline or add components under `XRoads/Views/Components`._")
        } else {
            lines.append("")
            for component in context.components {
                let description = component.description?.trimmingCharacters(in: .whitespacesAndNewlines)
                let baseDescription = description?.isEmpty == false ? description! : "Reusable UI component."
                var line = "- `\(component.name)` â€” \(baseDescription) Usage: `\(component.usageExample)`"
                if !component.tokens.isEmpty {
                    let tokenList = component.tokens.joined(separator: ", ")
                    line += " Tokens: `\(tokenList)`"
                }
                if let filePath = component.filePath {
                    line += " Source: `\(filePath)`"
                }
                lines.append(line)
            }
        }

        if !context.missingComponents.isEmpty {
            lines.append("")
            lines.append("### Warnings")
            for component in context.missingComponents {
                var warning = "- Missing component: `\(component.name)` (declared in art-bible.json, no matching Swift file found)"
                if !component.tokens.isEmpty {
                    warning += " Tokens: `\(component.tokens.joined(separator: ", "))`"
                }
                lines.append(warning)
            }
        }

        lines.append("## End Available Components")
        return lines.joined(separator: "\n")
    }

    @discardableResult
    func updateAgentsFile(at agentsURL: URL, projectURL: URL) throws -> ComponentContext {
        guard fileManager.fileExists(atPath: agentsURL.path) else {
            throw ComponentContextBuilderError.agentsFileNotFound(agentsURL.path)
        }

        let context = try buildContext(projectURL: projectURL)
        let section = renderSection(for: context)

        let currentContent: String
        do {
            currentContent = try String(contentsOf: agentsURL, encoding: .utf8)
        } catch {
            throw ComponentContextBuilderError.agentsFileReadFailed(agentsURL.path)
        }

        let updated = injectSection(section, into: currentContent)

        do {
            try updated.write(to: agentsURL, atomically: true, encoding: .utf8)
        } catch {
            throw ComponentContextBuilderError.agentsFileWriteFailed(agentsURL.path)
        }

        return context
    }

    // MARK: - Helpers

    private func injectSection(_ section: String, into content: String) -> String {
        let startMarker = "## Available Components"
        let endMarker = "## End Available Components"
        let skillsMarker = "## XRoads Skills (Auto-Injected)"

        if let startRange = content.range(of: startMarker),
           let endRange = content.range(of: endMarker, range: startRange.upperBound..<content.endIndex) {
            let before = content[..<startRange.lowerBound].trimmingCharacters(in: .whitespacesAndNewlines)
            let after = content[endRange.upperBound...].trimmingCharacters(in: .whitespacesAndNewlines)
            return [before, section, after]
                .filter { !$0.isEmpty }
                .joined(separator: "\n\n")
        }

        if let skillsRange = content.range(of: skillsMarker) {
            let before = content[..<skillsRange.lowerBound].trimmingCharacters(in: .whitespacesAndNewlines)
            let after = content[skillsRange.lowerBound...].trimmingCharacters(in: .whitespacesAndNewlines)
            return [before, section, after]
                .filter { !$0.isEmpty }
                .joined(separator: "\n\n")
        }

        let trimmed = content.trimmingCharacters(in: .whitespacesAndNewlines)
        if trimmed.isEmpty {
            return section
        }
        return "\(trimmed)\n\n\(section)"
    }

    private func findArtBible(in projectURL: URL) -> URL? {
        let candidates = ["art-bible.json", "art_bible.json"]
        for filename in candidates {
            let url = projectURL.appendingPathComponent(filename)
            if fileManager.fileExists(atPath: url.path) {
                return url
            }
        }
        return nil
    }

    private func loadArtBible(from url: URL) throws -> ArtBible {
        do {
            let data = try Data(contentsOf: url)
            let decoder = JSONDecoder()
            decoder.keyDecodingStrategy = .convertFromSnakeCase
            decoder.dateDecodingStrategy = .iso8601
            return try decoder.decode(ArtBible.self, from: data)
        } catch {
            throw ComponentContextBuilderError.artBibleDecodeFailed(url.path)
        }
    }

    private func components(from artBible: ArtBible) -> [ArtBibleComponent] {
        let explicit = artBible.allComponents
        if !explicit.isEmpty {
            return explicit
        }

        var supplemental: [ArtBibleComponent] = []
        if let tokens = artBible.designTokens {
            supplemental.append(
                ArtBibleComponent(
                    name: "Theme",
                    description: "Design tokens and shared constants for the UI system.",
                    tokens: ["design_tokens"],
                    styleSpecs: nil,
                    visualPrompt: nil,
                    interaction: nil
                )
            )

            if let colors = tokens.colors, !colors.isEmpty {
                supplemental.append(
                    ArtBibleComponent(
                        name: "Color Tokens",
                        description: "Color palette and semantic color tokens.",
                        tokens: colorTokenList(from: colors),
                        styleSpecs: nil,
                        visualPrompt: nil,
                        interaction: nil
                    )
                )
            }

            if tokens.typography != nil {
                supplemental.append(
                    ArtBibleComponent(
                        name: "Typography Tokens",
                        description: "Typography scale and font tokens.",
                        tokens: ["typography"],
                        styleSpecs: nil,
                        visualPrompt: nil,
                        interaction: nil
                    )
                )
            }

            if let spacing = tokens.spacing, !spacing.isEmpty {
                supplemental.append(
                    ArtBibleComponent(
                        name: "Spacing Scale",
                        description: "Spacing scale tokens.",
                        tokens: spacing.keys.sorted().map { "spacing.\($0)" },
                        styleSpecs: nil,
                        visualPrompt: nil,
                        interaction: nil
                    )
                )
            }

            if let radius = tokens.radius, !radius.isEmpty {
                supplemental.append(
                    ArtBibleComponent(
                        name: "Radius Scale",
                        description: "Corner radius tokens.",
                        tokens: radius.keys.sorted().map { "radius.\($0)" },
                        styleSpecs: nil,
                        visualPrompt: nil,
                        interaction: nil
                    )
                )
            }
        }

        if let colorSystem = artBible.colorSystem, !colorSystem.isEmpty {
            supplemental.append(
                ArtBibleComponent(
                    name: "Color System",
                    description: "Semantic color system assets.",
                    tokens: colorSystem.keys.sorted().map { "color_system.\($0)" },
                    styleSpecs: nil,
                    visualPrompt: nil,
                    interaction: nil
                )
            )
        }

        if let typographySystem = artBible.typographySystem, !typographySystem.isEmpty {
            supplemental.append(
                ArtBibleComponent(
                    name: "Typography System",
                    description: "Typography system specifications.",
                    tokens: typographySystem.keys.sorted().map { "typography_system.\($0)" },
                    styleSpecs: nil,
                    visualPrompt: nil,
                    interaction: nil
                )
            )
        }

        return supplemental
    }

    private func colorTokenList(from colors: [String: [String: String]]) -> [String] {
        let groups = colors.keys.sorted()
        guard !groups.isEmpty else {
            return ["design_tokens.colors"]
        }
        return groups.flatMap { group in
            let tokens = colors[group]?.keys.sorted() ?? []
            if tokens.isEmpty {
                return ["colors.\(group)"]
            }
            return tokens.map { "colors.\(group).\($0)" }
        }
    }

    private func scanCodeComponents(in projectURL: URL) -> [ComponentContext.Component] {
        let componentsURL = projectURL.appendingPathComponent("XRoads/Views/Components")
        guard fileManager.fileExists(atPath: componentsURL.path) else {
            return []
        }

        let files: [URL]
        do {
            files = try fileManager.contentsOfDirectory(
                at: componentsURL,
                includingPropertiesForKeys: nil,
                options: [.skipsHiddenFiles]
            )
        } catch {
            return []
        }

        return files
            .filter { $0.pathExtension == "swift" }
            .map { url in
                let name = url.deletingPathExtension().lastPathComponent
                let relativePath = url.path.replacingOccurrences(of: projectURL.path + "/", with: "")
                return ComponentContext.Component(
                    name: name,
                    description: "SwiftUI component in the shared components library.",
                    usageExample: "\(name)(...)",
                    tokens: [],
                    source: .codebase,
                    filePath: relativePath
                )
            }
    }

    private func themeComponent(in projectURL: URL) -> ComponentContext.Component? {
        let themeURL = projectURL.appendingPathComponent("XRoads/Resources/Theme.swift")
        guard fileManager.fileExists(atPath: themeURL.path) else {
            return nil
        }

        let relativePath = themeURL.path.replacingOccurrences(of: projectURL.path + "/", with: "")
        return ComponentContext.Component(
            name: "Theme",
            description: "Design tokens, spacing, radius, and layout constants.",
            usageExample: "Text(\"Example\").padding(Theme.Spacing.md).background(Color.bgSurface)",
            tokens: [],
            source: .theme,
            filePath: relativePath
        )
    }

    private func merge(existing: ComponentContext.Component, artBible: ComponentContext.Component) -> ComponentContext.Component {
        let description = artBible.description ?? existing.description
        let usage = artBible.usageExample.isEmpty ? existing.usageExample : artBible.usageExample
        let tokens = artBible.tokens.isEmpty ? existing.tokens : artBible.tokens

        return ComponentContext.Component(
            name: existing.name,
            description: description,
            usageExample: usage,
            tokens: tokens,
            source: existing.source,
            filePath: existing.filePath
        )
    }

    private func usageExample(for name: String, tokens: [String]) -> String {
        let lower = name.lowercased()

        if lower.contains("theme") {
            return "Text(\"Example\").padding(Theme.Spacing.md).background(Color.bgSurface)"
        }

        if lower.contains("color") {
            return "RoundedRectangle(cornerRadius: Theme.Radius.sm).fill(Color.bgSurface)"
        }

        if lower.contains("typography") {
            return "Text(\"Example\").font(.body14)"
        }

        if lower.contains("spacing") {
            return "VStack(spacing: Theme.Spacing.md) { ... }"
        }

        if lower.contains("radius") {
            return "RoundedRectangle(cornerRadius: Theme.Radius.md)"
        }

        let identifier = swiftIdentifier(from: name)
        return "\(identifier)(...)"
    }

    private func normalizedName(_ name: String) -> String {
        String(name.lowercased().filter { $0.isLetter || $0.isNumber })
    }

    private func swiftIdentifier(from name: String) -> String {
        let parts = name
            .split { !$0.isLetter && !$0.isNumber }
            .map { String($0) }
        let joined = parts.map { $0.prefix(1).uppercased() + $0.dropFirst() }.joined()
        return joined.isEmpty ? name.replacingOccurrences(of: " ", with: "") : joined
    }
}
