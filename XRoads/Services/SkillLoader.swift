import Foundation

/// Service for loading and injecting skills into AGENT.md files
/// Handles template rendering and skill prompt assembly
actor SkillLoader {
    /// Singleton instance
    static let shared = SkillLoader()

    /// Reference to the skill registry
    private let registry: SkillRegistry

    // MARK: - Initialization

    init(registry: SkillRegistry = .shared) {
        self.registry = registry
    }

    // MARK: - AGENT.md Generation

    /// Generate AGENT.md content with injected skills
    /// - Parameters:
    ///   - skills: Skills to inject
    ///   - context: Additional context to include (PRD info, task details, etc.)
    ///   - worktreePath: Path to the worktree (for file references)
    /// - Returns: Generated AGENT.md content
    func generateAgentMD(
        skills: [Skill],
        context: SkillContext,
        worktreePath: String
    ) -> String {
        var sections: [String] = []

        // Header
        sections.append(generateHeader(context: context))

        // Mission/Task section
        sections.append(generateMissionSection(context: context))

        // Skills section
        if !skills.isEmpty {
            sections.append(generateSkillsSection(skills: skills, context: context))
        }

        // Coordination section (for multi-agent scenarios)
        if let coordination = context.coordinationNotes {
            sections.append(generateCoordinationSection(notes: coordination))
        }

        // Completion criteria
        sections.append(generateCompletionSection(context: context))

        return sections.joined(separator: "\n\n")
    }

    /// Inject skills into an existing AGENT.md template
    /// - Parameters:
    ///   - template: The existing AGENT.md template content
    ///   - skills: Skills to inject
    ///   - context: Context for placeholder replacement
    /// - Returns: Rendered template with skills injected
    func injectSkills(
        into template: String,
        skills: [Skill],
        context: SkillContext
    ) -> String {
        var result = template

        // Replace {{skills}} placeholder with skill prompts
        let skillsContent = skills.map { renderSkillPrompt($0, context: context) }
            .joined(separator: "\n\n---\n\n")
        result = result.replacingOccurrences(of: "{{skills}}", with: skillsContent)

        // Replace {{context}} in the result
        result = result.replacingOccurrences(of: "{{context}}", with: context.toContextString())

        // Replace other common placeholders
        result = replacePlaceholders(in: result, context: context)

        return result
    }

    /// Load skills by IDs and generate combined prompt
    /// - Parameters:
    ///   - skillIDs: Array of skill IDs to load
    ///   - cliType: The CLI type (for filtering compatible skills)
    ///   - context: Context for rendering
    /// - Returns: Combined skill prompts
    func loadAndRenderSkills(
        ids skillIDs: [String],
        for cliType: AgentType,
        context: SkillContext
    ) async -> String {
        let skills = await registry.skills(byIDs: skillIDs)
            .filter { $0.isCompatible(with: cliType) }

        return skills.map { renderSkillPrompt($0, context: context) }
            .joined(separator: "\n\n---\n\n")
    }

    /// Get skills required for an action
    /// - Parameters:
    ///   - action: The action type
    ///   - cliType: The CLI type
    /// - Returns: Array of compatible skills for the action
    func skills(for action: ActionType, cli cliType: AgentType) async -> [Skill] {
        let requiredIDs = action.requiredSkills
        return await registry.skills(byIDs: requiredIDs)
            .filter { $0.isCompatible(with: cliType) }
    }

    // MARK: - Skill Rendering

    /// Render a single skill's prompt with context substitution
    /// - Parameters:
    ///   - skill: The skill to render
    ///   - context: Context for placeholder replacement
    /// - Returns: Rendered prompt
    func renderSkillPrompt(_ skill: Skill, context: SkillContext) -> String {
        var prompt = skill.promptTemplate

        // Replace {{context}} placeholder
        prompt = prompt.replacingOccurrences(of: "{{context}}", with: context.toContextString())

        // Replace other placeholders
        prompt = replacePlaceholders(in: prompt, context: context)

        return """
            ## \(skill.name)

            \(prompt)
            """
    }

    // MARK: - Private Helpers

    private func generateHeader(context: SkillContext) -> String {
        """
        # AGENT.md - \(context.agentType.displayName) Mission Brief

        Generated by XRoads on \(ISO8601DateFormatter().string(from: Date()))
        """
    }

    private func generateMissionSection(context: SkillContext) -> String {
        var section = "## Mission\n\n"

        if let prdPath = context.prdPath {
            section += "**PRD**: `\(prdPath)`\n\n"
        }

        if !context.assignedStories.isEmpty {
            section += "**Assigned Stories**:\n"
            for story in context.assignedStories {
                section += "- \(story)\n"
            }
            section += "\n"
        }

        if let task = context.taskDescription {
            section += "**Task**: \(task)\n"
        }

        return section
    }

    private func generateSkillsSection(skills: [Skill], context: SkillContext) -> String {
        var section = "## Loaded Skills\n\n"

        for skill in skills {
            section += renderSkillPrompt(skill, context: context)
            section += "\n\n"
        }

        return section
    }

    private func generateCoordinationSection(notes: String) -> String {
        """
        ## Coordination

        \(notes)
        """
    }

    private func generateCompletionSection(context: SkillContext) -> String {
        var section = "## Completion Criteria\n\n"

        section += "Mark your work complete when:\n"
        section += "1. All assigned stories are implemented\n"
        section += "2. Unit tests pass\n"
        section += "3. Code builds without errors\n"
        section += "4. Changes are committed with proper message format\n"

        if let extraCriteria = context.completionCriteria {
            section += "\nAdditional criteria:\n"
            for criterion in extraCriteria {
                section += "- \(criterion)\n"
            }
        }

        return section
    }

    private func replacePlaceholders(in text: String, context: SkillContext) -> String {
        var result = text

        // Replace known placeholders
        result = result.replacingOccurrences(of: "{{agent_type}}", with: context.agentType.rawValue)
        result = result.replacingOccurrences(of: "{{agent_name}}", with: context.agentType.displayName)
        result = result.replacingOccurrences(of: "{{branch}}", with: context.branch ?? "main")
        result = result.replacingOccurrences(of: "{{worktree_path}}", with: context.worktreePath ?? "")

        if let prd = context.prdPath {
            result = result.replacingOccurrences(of: "{{prd_path}}", with: prd)
        }

        if let session = context.sessionID {
            result = result.replacingOccurrences(of: "{{session_id}}", with: session)
        }

        // Replace stories list
        let storiesList = context.assignedStories.joined(separator: ", ")
        result = result.replacingOccurrences(of: "{{assigned_stories}}", with: storiesList)

        return result
    }
}

// MARK: - SkillContext

/// Context data for skill template rendering
struct SkillContext: Sendable {
    /// The CLI agent type
    let agentType: AgentType

    /// Path to the worktree (optional)
    let worktreePath: String?

    /// Current branch name (optional)
    let branch: String?

    /// Path to the PRD file (optional)
    let prdPath: String?

    /// Path to art-bible.json if present (optional)
    let artBiblePath: String?

    /// Session ID for tracking (optional)
    let sessionID: String?

    /// Assigned story IDs
    let assignedStories: [String]

    /// Task description (optional)
    let taskDescription: String?

    /// Coordination notes for multi-agent scenarios (optional)
    let coordinationNotes: String?

    /// Additional completion criteria (optional)
    let completionCriteria: [String]?

    /// Custom context key-value pairs
    let customContext: [String: String]

    init(
        agentType: AgentType,
        worktreePath: String? = nil,
        branch: String? = nil,
        prdPath: String? = nil,
        artBiblePath: String? = nil,
        sessionID: String? = nil,
        assignedStories: [String] = [],
        taskDescription: String? = nil,
        coordinationNotes: String? = nil,
        completionCriteria: [String]? = nil,
        customContext: [String: String] = [:]
    ) {
        self.agentType = agentType
        self.worktreePath = worktreePath
        self.branch = branch
        self.prdPath = prdPath
        self.artBiblePath = artBiblePath
        self.sessionID = sessionID
        self.assignedStories = assignedStories
        self.taskDescription = taskDescription
        self.coordinationNotes = coordinationNotes
        self.completionCriteria = completionCriteria
        self.customContext = customContext
    }

    /// Convert context to a string for {{context}} placeholder
    func toContextString() -> String {
        var lines: [String] = []

        if let path = worktreePath {
            lines.append("Working directory: \(path)")
        }

        if let branch = branch {
            lines.append("Branch: \(branch)")
        }

        if !assignedStories.isEmpty {
            lines.append("Stories: \(assignedStories.joined(separator: ", "))")
        }

        if let task = taskDescription {
            lines.append("Task: \(task)")
        }

        if let artBible = artBiblePath {
            lines.append("Art Bible: \(artBible)")
        }

        for (key, value) in customContext.sorted(by: { $0.key < $1.key }) {
            lines.append("\(key): \(value)")
        }

        return lines.joined(separator: "\n")
    }
}

// MARK: - SkillLoader File Operations

extension SkillLoader {
    /// Write AGENT.md to a worktree
    /// - Parameters:
    ///   - content: The AGENT.md content
    ///   - worktreePath: Path to the worktree
    func writeAgentMD(content: String, to worktreePath: String) throws {
        let filePath = (worktreePath as NSString).appendingPathComponent("AGENT.md")
        try content.write(toFile: filePath, atomically: true, encoding: .utf8)
    }

    /// Read existing AGENT.md from a worktree
    /// - Parameter worktreePath: Path to the worktree
    /// - Returns: The file content, or nil if not found
    func readAgentMD(from worktreePath: String) -> String? {
        let filePath = (worktreePath as NSString).appendingPathComponent("AGENT.md")
        return try? String(contentsOfFile: filePath, encoding: .utf8)
    }
}
