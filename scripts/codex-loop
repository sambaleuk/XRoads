#!/bin/bash
#
# Nexus Loop - Autonomous AI Agent for Feature Implementation (Codex CLI)
# Part of XRoads / Nexus Scripts
#
# Usage: codex-loop [max_iterations] [sleep_seconds]
#

set -e
set -o pipefail

# Find script directory and load common library
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Try bundled lib first, then fallback to ~/.nexus
if [[ -f "${SCRIPT_DIR}/lib/common.sh" ]]; then
    source "${SCRIPT_DIR}/lib/common.sh"
elif [[ -f "${HOME}/.nexus/lib/common.sh" ]]; then
    source "${HOME}/.nexus/lib/common.sh"
else
    echo "Error: common.sh not found"
    exit 1
fi

# Configuration
MAX_ITERATIONS=${1:-12}
SLEEP_SECONDS=${2:-4}
LOG_DIR="logs"
MAX_CONSECUTIVE_FAILURES=3
mkdir -p "$LOG_DIR"

# ============================================================================
# INITIALIZATION
# ============================================================================
init() {
    show_nexus_banner "Codex" "$GREEN"

    log_info "Checking dependencies..."
    check_codex_deps || exit 1

    if [ ! -f "$PRD_FILE" ]; then
        log_error "PRD file not found: $PRD_FILE"
        echo "Create with: nexus-init <feature-name> or /prd skill"
        exit 1
    fi

    # Init progress file if missing
    if [ ! -f "$PROGRESS_FILE" ]; then
        local feature=$(prd_get_feature_name)
        create_progress_file "$feature" > "$PROGRESS_FILE"
        log_success "Created $PROGRESS_FILE"
    fi

    # Init AGENTS.md if missing
    if [ ! -f "$AGENTS_FILE" ]; then
        create_agents_file > "$AGENTS_FILE"
        log_success "Created $AGENTS_FILE"
    fi

    log_success "All dependencies OK"
}

build_prompt() {
    local iteration="$1"
    cat <<PROMPT
You are Codex Nexus, an autonomous coding agent. Do exactly ONE task per iteration.

## Mission Context
- PRD: $PRD_FILE
- Progress log: $PROGRESS_FILE

## Steps

1. Read $PRD_FILE and pick the first user story whose status != "complete".
2. Read $AGENTS_FILE for reusable patterns.
3. Implement exactly ONE story per iteration.
4. Run quality gates (lint, test, build).
5. Update artifacts:
   - If checks pass: set story status -> "complete", commit changes
   - If checks fail: log learnings to $PROGRESS_FILE, do NOT commit

## Progress Block Format

### Iteration $iteration - [Story ID]
- Delta: ...
- Checks: ...
- Learnings: ...

## Completion Protocol

After applying changes, inspect $PRD_FILE:
- If every story is complete, output <codex-complete>ALL DONE</codex-complete>
- Otherwise end the response so the next iteration can continue.
PROMPT
}

# ============================================================================
# MAIN LOOP
# ============================================================================
main() {
    init

    local pending=$(prd_count_pending)
    local total=$(prd_count_total)
    local feature_name=$(prd_get_feature_name)

    if [ "$pending" = "0" ]; then
        log_success "All stories already complete!"
        exit 0
    fi

    log_info "Starting loop: $pending/$total stories remaining"
    log_info "Feature: ${YELLOW}$feature_name${NC}"
    log_info "Max iterations: $MAX_ITERATIONS"
    echo ""

    local consecutive_failures=0

    for ((i=1; i<=MAX_ITERATIONS; i++)); do
        pending=$(prd_count_pending)
        total=$(prd_count_total)
        local complete=$((total - pending))

        show_iteration_header "$i" "$MAX_ITERATIONS" "$complete" "$total"

        local prompt=$(build_prompt "$i")
        local timestamp=$(date '+%Y%m%d_%H%M%S')
        local iter_log="$LOG_DIR/codex_loop_iter_${i}_$timestamp.log"
        local iter_last="$LOG_DIR/codex_loop_iter_${i}_last.txt"

        echo -e "${DIM}─────────────────────────────────────────────${NC}"
        echo -e "${GREEN}Codex working...${NC}"
        echo ""

        set +e
        printf "%s" "$prompt" | codex --approval-mode full-auto --cd "$(pwd)" - 2>&1 | tee "$iter_log"
        local exit_code=${PIPESTATUS[1]}
        set -e

        # Save last output for completion check
        tail -100 "$iter_log" > "$iter_last" 2>/dev/null || true

        echo ""
        echo -e "${DIM}─────────────────────────────────────────────${NC}"

        if [ $exit_code -ne 0 ]; then
            log_warn "Codex exited with code $exit_code"
            consecutive_failures=$((consecutive_failures + 1))
            if [ $consecutive_failures -ge $MAX_CONSECUTIVE_FAILURES ]; then
                log_error "Reached $MAX_CONSECUTIVE_FAILURES consecutive failures. Aborting."
                exit 1
            fi
            log_info "Retrying after ${SLEEP_SECONDS}s (failure ${consecutive_failures}/${MAX_CONSECUTIVE_FAILURES})"
            sleep $SLEEP_SECONDS
            continue
        fi
        consecutive_failures=0

        # Check for completion
        if grep -q "<codex-complete>" "$iter_last" 2>/dev/null || grep -q "<codex-complete>" "$iter_log" 2>/dev/null; then
            show_completion_banner "$i" "$feature_name"
            exit 0
        fi

        # Check remaining
        pending=$(prd_count_pending)
        if [ "$pending" = "0" ]; then
            show_completion_banner "$i" "$feature_name"
            exit 0
        fi

        log_info "${YELLOW}$feature_name${NC} - $pending stories remaining. Next in ${SLEEP_SECONDS}s..."
        sleep $SLEEP_SECONDS
    done

    # Max iterations reached
    show_timeout_banner "$MAX_ITERATIONS" "$pending"
    exit 1
}

main
